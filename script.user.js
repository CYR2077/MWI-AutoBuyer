// ==UserScript==
// @name         Èì∂Ê≤≥Â•∂Áâõ-Ëá™Âä®ËÆ°ÁÆóË¥≠‰π∞ÊùêÊñô
// @name:en      MWI-AutoBuyer
// @namespace    http://tampermonkey.net/
// @version      2.0.0
// @description  Ëá™Âä®ËÆ°ÁÆóÈúÄË¶ÅÁöÑÊùêÊñôÊï∞ÈáèÔºå‰∏ÄÈîÆË¥≠‰π∞Áº∫Â∞ëÁöÑÊùêÊñô(Automatically calculate the required material quantities and purchase missing materials with one click.)
// @description:en  Automatically calculate the required material quantities and purchase missing materials with one click.
// @author       XIxixi297
// @license      CC-BY-NC-SA-4.0
// @match        https://www.milkywayidle.com/*
// @match        https://test.milkywayidle.com/*
// @icon         https://www.google.com/s2/favicons?sz=64&domain=milkywayidle.com
// @grant        none
// @run-at       document-start
// ==/UserScript==

(function () {
    'use strict';

    // ËÑöÊú¨Ê≥®ÂÖ•Ê†áÂøóÔºåÈò≤Ê≠¢ÈáçÂ§çÊ≥®ÂÖ•
    let scriptInjected = false;

    // ÂÜÖËÅîÁöÑËá™Âä®Ë¥≠‰π∞ËÑöÊú¨ÂÜÖÂÆπ
    const AUTO_BUY_SCRIPT = `
(function () {
    'use strict';

    // ÈÖçÁΩÆÂ∏∏Èáè
    const CONFIG = {
        LANG: {
            zh: {
                autoBuyButton: 'üõí Ëá™Âä®Ë¥≠‰π∞',
                autoBuyButtonActive: '‚è≥ Ë¥≠‰π∞‰∏≠...',
                missingPrefix: 'Áº∫:',
                missingUnit: '',
                noMaterialsNeeded: 'ÊùêÊñôÂÖÖË∂≥ÔºÅ',
                startPurchasing: 'ÂºÄÂßãË¥≠‰π∞',
                purchased: 'Â∑≤Ë¥≠‰π∞',
                purchaseFailed: 'Ë¥≠‰π∞Â§±Ë¥•',
                purchaseComplete: 'Ë¥≠‰π∞ÂÆåÊàêÔºÅ',
                purchaseError: 'Ë¥≠‰π∞Âá∫ÈîôÔºåËØ∑Ê£ÄÊü•ÊéßÂà∂Âè∞',
                wsNotAvailable: 'WebSocketÊó•ÂøóÊü•ÁúãÂô®Êú™ÂèØÁî®ÔºåËØ∑Á°Æ‰øùÂ∑≤ÂêØÁî®',
                waitingForLogger: 'Á≠âÂæÖWebSocketÊó•ÂøóÊü•ÁúãÂô®...',
                loggerReady: 'WebSocketÊó•ÂøóÊü•ÁúãÂô®Â∑≤Â∞±Áª™ÔºÅ',
                requestFailed: 'ËØ∑Ê±ÇÂ§±Ë¥•',
                requestTimeout: 'ËØ∑Ê±ÇË∂ÖÊó∂',
                allPurchasesFailed: 'ÊâÄÊúâË¥≠‰π∞ÈÉΩÂ§±Ë¥•‰∫ÜÔºåËØ∑Ê£ÄÊü•ÊéßÂà∂Âè∞',
                purchaseSuccess: 'ÊàêÂäüË¥≠‰π∞',
                materials: 'ÁßçÊùêÊñô',
                totalCost: 'ÂÖ±Ëä±Ë¥π',
                coins: 'ÈáëÂ∏Å',
                each: '‰∏™'
            },
            en: {
                autoBuyButton: 'üõí Auto Buy',
                autoBuyButtonActive: '‚è≥ Buying...',
                missingPrefix: 'Need:',
                missingUnit: '',
                noMaterialsNeeded: 'All materials sufficient!',
                startPurchasing: 'Start purchasing',
                purchased: 'Purchased',
                purchaseFailed: 'Purchase failed',
                purchaseComplete: 'Purchase completed!',
                purchaseError: 'Purchase error, check console',
                wsNotAvailable: 'WebSocket logger not available, ensure it is enabled',
                waitingForLogger: 'Waiting for WebSocket logger...',
                loggerReady: 'WebSocket logger ready!',
                requestFailed: 'Request failed',
                requestTimeout: 'Request timeout',
                allPurchasesFailed: 'All purchases failed, check console',
                purchaseSuccess: 'Successfully purchased',
                materials: 'materials',
                totalCost: 'total cost',
                coins: 'coins',
                each: ''
            }
        },
        SELECTORS: {
            production: {
                container: '.SkillActionDetail_regularComponent__3oCgr',
                input: '.Input_input__2-t98',
                requirements: '.SkillActionDetail_itemRequirements__3SPnA',
                nameDiv: '.SkillActionDetail_name__3erHV',
                inventoryCount: '.SkillActionDetail_inventoryCount__tHmPD',
                inputCount: '.SkillActionDetail_inputCount__1rdrn'
            },
            house: {
                container: '.HousePanel_modalContent__3AwPH',
                requirements: '.HousePanel_itemRequirements__1qFjZ',
                headerDiv: '.HousePanel_header__3QdpP',
                inventoryCount: '.HousePanel_inventoryCount__YxePN',
                inputCount: '.HousePanel_inputCount__26GPq'
            },
            common: {
                itemContainer: '.Item_itemContainer__x7kH1',
                itemName: '.Item_name__2C42x',
                inventoryItems: '.Inventory_inventory__17CH2 .Item_item__2De2O'
            }
        },
        STYLES: {
            button: {
                padding: '0 10px',
                backgroundColor: 'var(--color-primary)',
                color: 'var(--color-text-dark-mode)',
                border: 'none',
                borderRadius: '4px',
                cursor: 'pointer',
                fontSize: '14px',
                fontWeight: '600',
                transition: 'all 0.2s ease',
                fontFamily: '"Roboto"',
                textAlign: 'center',
                userSelect: 'none',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                height: '36px',
                lineHeight: '15px',
                minWidth: 'auto',
                overflow: 'hidden'
            },
            infoSpan: {
                fontSize: '12px',
                fontWeight: 'bold',
                padding: '2px 6px',
                borderRadius: '3px',
                whiteSpace: 'nowrap',
                minWidth: '60px',
                textAlign: 'center'
            }
        }
    };

    const lang = (navigator.language || 'en').toLowerCase().includes('zh') ? 'zh' : 'en';
    const L = CONFIG.LANG[lang];

    // PostMessage ÈÄö‰ø°ÁÆ°ÁêÜÂô®
    class PostMessageAPI {
        constructor() {
            this.pendingRequests = new Map();
            this.requestIdCounter = 1;
            this.setupMessageListener();
        }

        setupMessageListener() {
            window.addEventListener('message', (event) => {
                if (event.origin !== window.location.origin) return;

                const message = event.data;
                if (!message || message.type !== 'ws_response') return;

                const pendingRequest = this.pendingRequests.get(message.requestId);
                if (pendingRequest) {
                    this.pendingRequests.delete(message.requestId);
                    clearTimeout(pendingRequest.timeout);

                    if (message.success) {
                        pendingRequest.resolve(message.data);
                    } else {
                        pendingRequest.reject(new Error(message.error || L.requestFailed));
                    }
                }
            });

            // ÁõëÂê¨WebSocketÂ∞±Áª™Ê∂àÊÅØ
            window.addEventListener('message', (event) => {
                if (event.origin !== window.location.origin) return;

                const message = event.data;
                if (message.type === 'ws_ready') {
                    this.checkAPI();
                }
            });
        }

        async sendRequest(action, data = {}, timeout = 30000) {
            const requestId = \`req_\${this.requestIdCounter++}_\${Date.now()}\`;

            return new Promise((resolve, reject) => {
                const timeoutId = setTimeout(() => {
                    this.pendingRequests.delete(requestId);
                    reject(new Error(\`\${L.requestTimeout}: \${action}\`));
                }, timeout);

                this.pendingRequests.set(requestId, {
                    resolve,
                    reject,
                    timeout: timeoutId
                });

                window.postMessage({
                    type: 'ws_request',
                    action: action,
                    data: data,
                    requestId: requestId
                }, window.location.origin);
            });
        }

        async checkAPI() {
            try {
                const result = await this.sendRequest('check_api', {}, 5000);
                return result;
            } catch (error) {
                return { available: false };
            }
        }

        async batchPurchase(items, delayBetween = 800) {
            return await this.sendRequest('batch_purchase', { items, delayBetween });
        }
    }

    // Ê†∏ÂøÉÂ∑•ÂÖ∑Á±ª
    class Utils {
        static parseNumber(text) {
            if (!text) return 0;
            const match = text.match(/^([\\d,]+(?:\\.\\d+)?)\\s*([KMB])$/i);
            if (!match) return parseInt(text.replace(/[^\\d]/g, ''), 10) || 0;

            let num = parseFloat(match[1].replace(/,/g, ''));
            const multipliers = { K: 1000, M: 1000000, B: 1000000000 };
            return Math.floor(num * (multipliers[match[2].toUpperCase()] || 1));
        }

        static applyStyles(element, styles) {
            Object.assign(element.style, styles);
        }

        // ‰ªéSVGÊèêÂèñÁâ©ÂìÅID
        static extractItemId(svgElement) {
            if (!svgElement) return null;
            const useElement = svgElement.querySelector('use');
            if (!useElement) return null;
            const href = useElement.getAttribute('href');
            if (!href) return null;
            const match = href.match(/#(.+)$/);
            return match ? match[1] : null;
        }
    }

    // ÈÄöÁü•Á≥ªÁªü
    class Toast {
        constructor() {
            this.container = null;
            this.init();
        }

        init() {
            if (this.container) return;
            this.container = document.createElement('div');
            Utils.applyStyles(this.container, {
                position: 'fixed',
                top: '20px',
                left: '50%',
                transform: 'translateX(-50%)',
                zIndex: '10000',
                pointerEvents: 'none'
            });
            document.body.appendChild(this.container);
        }

        show(message, type = 'info', duration = 3000) {
            const toast = document.createElement('div');
            toast.textContent = message;

            const colors = { info: '#2196F3', success: '#4CAF50', warning: '#FF9800', error: '#F44336' };
            Utils.applyStyles(toast, {
                background: colors[type],
                color: 'white',
                padding: '12px 24px',
                borderRadius: '6px',
                marginBottom: '10px',
                fontSize: '14px',
                fontWeight: '500',
                opacity: '0',
                transform: 'translateY(-20px)',
                transition: 'all 0.3s ease',
                boxShadow: '0 4px 12px rgba(0,0,0,0.3)'
            });

            this.container.appendChild(toast);

            setTimeout(() => Utils.applyStyles(toast, { opacity: '1', transform: 'translateY(0)' }), 10);
            setTimeout(() => {
                Utils.applyStyles(toast, { opacity: '0', transform: 'translateY(-20px)' });
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }
    }

    // ÊùêÊñôÈúÄÊ±ÇËÆ°ÁÆóÂô®
    class MaterialCalculator {
        static async getItemQuantity(itemName) {
            const inventoryItems = document.querySelectorAll(CONFIG.SELECTORS.common.inventoryItems);
            const targetItem = Array.from(inventoryItems).find(item => {
                const svg = item.querySelector('svg[aria-label]');
                return svg?.getAttribute('aria-label') === itemName;
            });

            if (!targetItem) return 0;

            const countElement = targetItem.querySelector('.Item_count__1HVvv');
            if (!countElement) return 0;

            const countText = countElement.textContent.trim();

            // Â¶ÇÊûúÊòØÁÆÄÂÜôÊ†ºÂºèÔºåÈúÄË¶ÅÈÄöËøátooltipËé∑ÂèñÂáÜÁ°ÆÊï∞Èáè
            if (/\\d+[KMB]$/i.test(countText)) {
                return new Promise((resolve) => {
                    // Ê∏ÖÁêÜÁé∞ÊúâÁöÑtooltip
                    document.querySelectorAll('.ItemTooltipText_itemTooltipText__zFq3A').forEach(tooltip => {
                        if (tooltip.parentElement) tooltip.parentElement.style.display = 'none';
                    });

                    // Ëß¶Âèëmouseover‰∫ã‰ª∂ÊòæÁ§∫tooltip
                    targetItem.dispatchEvent(new MouseEvent("mouseover", { bubbles: true }));

                    const checkTooltip = (attempts = 0) => {
                        const tooltip = document.querySelector('.ItemTooltipText_itemTooltipText__zFq3A');

                        if (tooltip && tooltip.innerText && attempts < 20) {
                            // Â∞ùËØïÂ§öÁßçÊ®°ÂºèÂåπÈÖçÂáÜÁ°ÆÊï∞Èáè
                            const patterns = [
                                /Êï∞Èáè[Ôºö:]\\s*([\\d,]+)/i,           // ‰∏≠Êñá: Êï∞Èáè: 1,234
                                /Quantity[Ôºö:]\\s*([\\d,]+)/i,       // Ëã±Êñá: Quantity: 1,234
                                /(\\d{1,3}(?:,\\d{3})*)/g           // ÈÄöÁî®: ÂåπÈÖçÊâÄÊúâÈÄóÂè∑ÂàÜÈöîÁöÑÊï∞Â≠ó
                            ];

                            for (const pattern of patterns) {
                                const match = tooltip.innerText.match(pattern);
                                if (match) {
                                    let num;
                                    if (pattern.global) {
                                        // ÂØπ‰∫éÂÖ®Â±ÄÂåπÈÖçÔºåÊâæÊúÄÂ§ßÁöÑÊï∞Â≠óÔºàÈÄöÂ∏∏ÊòØÊï∞ÈáèÔºâ
                                        num = Math.max(...match.map(m => parseInt(m.replace(/,/g, ''), 10)));
                                    } else {
                                        // ÂØπ‰∫éÂÖ∑‰ΩìÂåπÈÖçÔºåÂèñÁ¨¨‰∏Ä‰∏™ÊçïËé∑ÁªÑ
                                        num = parseInt(match[1].replace(/,/g, ''), 10);
                                    }

                                    if (num && num > 0) {
                                        // ÈöêËóètooltip
                                        setTimeout(() => {
                                            if (tooltip.parentElement) {
                                                tooltip.parentElement.style.display = 'none';
                                            }
                                        }, 100);

                                        resolve(num);
                                        return;
                                    }
                                }
                            }
                        }

                        // Â¶ÇÊûúËøòÊ≤°ÊúâÊâæÂà∞tooltipÊàñËß£ÊûêÂ§±Ë¥•ÔºåÁªßÁª≠Â∞ùËØï
                        if (attempts < 20) {
                            setTimeout(() => checkTooltip(attempts + 1), 200);
                        } else {
                            // Â¶ÇÊûútooltipËé∑ÂèñÂ§±Ë¥•ÔºåÂõûÈÄÄÂà∞Ëß£ÊûêÁÆÄÂÜôÊ†ºÂºè
                            resolve(Utils.parseNumber(countText));
                        }
                    };

                    // Áªôtooltip‰∏Ä‰∫õÊó∂Èó¥ÊòæÁ§∫
                    setTimeout(checkTooltip, 300);
                });
            }

            return Utils.parseNumber(countText);
        }

        // Êñ∞Â¢ûÔºö‰ªé‰ªªÊÑèÂÖÉÁ¥†Ëé∑ÂèñÁ≤æÁ°ÆÊï∞ÈáèÔºàÁî®‰∫éÊàøÂ±ãÁïåÈù¢ÁöÑÈúÄÊ±ÇÊï∞ÈáèÔºâ
        static async getExactQuantityFromElement(element) {
            if (!element) return 0;
            
            const countText = element.textContent.trim();
            
            // Â¶ÇÊûúÊòØÁÆÄÂÜôÊ†ºÂºèÔºåÈúÄË¶ÅÈÄöËøátooltipËé∑ÂèñÂáÜÁ°ÆÊï∞Èáè
            if (/\\d+[KMB]$/i.test(countText)) {
                return new Promise((resolve) => {
                    // Ê∏ÖÁêÜÁé∞ÊúâÁöÑtooltip
                    document.querySelectorAll('.ItemTooltipText_itemTooltipText__zFq3A').forEach(tooltip => {
                        if (tooltip.parentElement) tooltip.parentElement.style.display = 'none';
                    });

                    // Ëß¶Âèëmouseover‰∫ã‰ª∂ÊòæÁ§∫tooltip
                    element.dispatchEvent(new MouseEvent("mouseover", { bubbles: true }));

                    const checkTooltip = (attempts = 0) => {
                        const tooltip = document.querySelector('.ItemTooltipText_itemTooltipText__zFq3A');

                        if (tooltip && tooltip.innerText && attempts < 20) {
                            // Â∞ùËØïÂ§öÁßçÊ®°ÂºèÂåπÈÖçÂáÜÁ°ÆÊï∞Èáè
                            const patterns = [
                                /Êï∞Èáè[Ôºö:]\\s*([\\d,]+)/i,           // ‰∏≠Êñá: Êï∞Èáè: 1,234
                                /Amount[Ôºö:]\\s*([\\d,]+)/i,       // Ëã±Êñá: Amount: 1,234
                                /(\\d{1,3}(?:,\\d{3})*)/g           // ÈÄöÁî®: ÂåπÈÖçÊâÄÊúâÈÄóÂè∑ÂàÜÈöîÁöÑÊï∞Â≠ó
                            ];

                            for (const pattern of patterns) {
                                const match = tooltip.innerText.match(pattern);
                                if (match) {
                                    let num;
                                    if (pattern.global) {
                                        // ÂØπ‰∫éÂÖ®Â±ÄÂåπÈÖçÔºåÊâæÊúÄÂ§ßÁöÑÊï∞Â≠óÔºàÈÄöÂ∏∏ÊòØÊï∞ÈáèÔºâ
                                        num = Math.max(...match.map(m => parseInt(m.replace(/,/g, ''), 10)));
                                    } else {
                                        // ÂØπ‰∫éÂÖ∑‰ΩìÂåπÈÖçÔºåÂèñÁ¨¨‰∏Ä‰∏™ÊçïËé∑ÁªÑ
                                        num = parseInt(match[1].replace(/,/g, ''), 10);
                                    }

                                    if (num && num > 0) {
                                        // ÈöêËóètooltip
                                        setTimeout(() => {
                                            if (tooltip.parentElement) {
                                                tooltip.parentElement.style.display = 'none';
                                            }
                                        }, 100);

                                        resolve(num);
                                        return;
                                    }
                                }
                            }
                        }

                        // Â¶ÇÊûúËøòÊ≤°ÊúâÊâæÂà∞tooltipÊàñËß£ÊûêÂ§±Ë¥•ÔºåÁªßÁª≠Â∞ùËØï
                        if (attempts < 20) {
                            setTimeout(() => checkTooltip(attempts + 1), 200);
                        } else {
                            // Â¶ÇÊûútooltipËé∑ÂèñÂ§±Ë¥•ÔºåÂõûÈÄÄÂà∞Ëß£ÊûêÁÆÄÂÜôÊ†ºÂºè
                            resolve(Utils.parseNumber(countText));
                        }
                    };

                    // Áªôtooltip‰∏Ä‰∫õÊó∂Èó¥ÊòæÁ§∫
                    setTimeout(checkTooltip, 300);
                });
            }

            return Utils.parseNumber(countText);
        }

        static async calculateRequirements(type) {
            const selectors = CONFIG.SELECTORS[type];
            const container = document.querySelector(selectors.container);
            if (!container) return [];

            const requirements = [];
            let productionQuantity = 1;

            // Ëé∑ÂèñÁîü‰∫ßÊï∞ÈáèÔºà‰ªÖÁîü‰∫ßÊ®°ÂºèÔºâ
            if (type === 'production') {
                const input = document.querySelector(selectors.input);
                productionQuantity = parseInt(input?.value) || 0;
            }

            const requirementsContainer = container.querySelector(selectors.requirements);
            if (!requirementsContainer) return [];

            const materialContainers = requirementsContainer.querySelectorAll(CONFIG.SELECTORS.common.itemContainer);
            const inventoryCounts = requirementsContainer.querySelectorAll(selectors.inventoryCount);
            const inputCounts = requirementsContainer.querySelectorAll(selectors.inputCount);

            for (let i = 0; i < materialContainers.length; i++) {
                const nameElement = materialContainers[i].querySelector(CONFIG.SELECTORS.common.itemName);
                const svgElement = materialContainers[i].querySelector('svg[aria-label]');

                if (!nameElement || !svgElement) continue;

                const materialName = nameElement.textContent.trim();
                const itemId = Utils.extractItemId(svgElement);

                // ‰ΩøÁî®getItemQuantityÊñπÊ≥ïËé∑ÂèñÂáÜÁ°ÆÂ∫ìÂ≠ò
                const currentStock = await this.getItemQuantity(materialName);

                let totalNeeded = 0;
                if (type === 'production') {
                    const consumptionMatch = inputCounts[i]?.textContent.match(/\\d+\\.?\\d*/);
                    const consumptionPerUnit = consumptionMatch ? parseFloat(consumptionMatch[0]) : 0;
                    totalNeeded = Math.ceil(productionQuantity * consumptionPerUnit);
                } else {
                    // ÊàøÂ±ãÊ®°ÂºèÁöÑÈÄªËæë - ‰øÆÊîπÈÉ®ÂàÜ
                    const neededMatch = inputCounts[i]?.textContent.match(/\\/\\s*([\\d,]+(?:\\.\\d+)?[KMB]?)\\s*/);
                    if (neededMatch) {
                        // Â¶ÇÊûúÂåπÈÖçÂà∞ÁöÑÊï∞Â≠óÂåÖÂê´KMBÔºå‰ΩøÁî®Á≤æÁ°ÆËé∑ÂèñÊñπÊ≥ï
                        if (/[KMB]$/i.test(neededMatch[1])) {
                            totalNeeded = await this.getExactQuantityFromElement(inputCounts[i]);
                        } else {
                            totalNeeded = Utils.parseNumber(neededMatch[1]);
                        }
                    }
                }

                const supplementNeeded = Math.max(0, totalNeeded - currentStock);

                requirements.push({
                    materialName,
                    itemId,
                    supplementNeeded,
                    totalNeeded,
                    currentStock,
                    index: i
                });
            }

            return requirements;
        }
    }

    // UIÁÆ°ÁêÜÂô®
    class UIManager {
        constructor() {
            this.toast = new Toast();
            this.postMessageAPI = new PostMessageAPI();
            this.observer = null;
            this.loggerReady = false;
            this.checkLoggerAndInit();
        }

        async checkLoggerAndInit() {
            const checkAPI = async () => {
                try {
                    const result = await this.postMessageAPI.checkAPI();
                    if (result.available && result.ws_ready) {
                        this.loggerReady = true;
                        console.log(\`%c[MWI-AutoBuyer] \${L.loggerReady}\`, 'color: #4CAF50; font-weight: bold;');
                        this.initObserver();
                        return true;
                    } else if (result.available) {
                        return false;
                    }
                } catch (error) {
                    // ÈùôÈªòÂ§ÑÁêÜ
                }
                return false;
            };

            if (!(await checkAPI())) {
                console.log(\`[MWI-AutoBuyer] \${L.waitingForLogger}\`);

                // ÂÆöÊúüÊ£ÄÊü•APIÂèØÁî®ÊÄß
                const pollAPI = async () => {
                    if (await checkAPI()) return;
                    setTimeout(pollAPI, 2000);
                };

                setTimeout(pollAPI, 3000);
            }
        }

        createButton(onClick) {
            const btn = document.createElement("button");
            btn.textContent = L.autoBuyButton;
            Utils.applyStyles(btn, CONFIG.STYLES.button);

            // ÊÇ¨ÂÅúÊïàÊûú - ‰ΩøÁî®ÂéüÊ∏∏ÊàèÁöÑhoverÈ¢úËâ≤
            btn.addEventListener("mouseenter", () => {
                Utils.applyStyles(btn, {
                    backgroundColor: "var(--color-primary-hover)"
                });
            });
            btn.addEventListener("mouseleave", () => {
                Utils.applyStyles(btn, {
                    backgroundColor: "var(--color-primary)"
                });
            });

            btn.addEventListener("click", async () => {
                if (!this.loggerReady) {
                    console.error(\`\${L.wsNotAvailable}\`);
                    return;
                }

                btn.disabled = true;
                btn.textContent = L.autoBuyButtonActive;
                Utils.applyStyles(btn, {
                    backgroundColor: "var(--color-disabled)",
                    cursor: "not-allowed"
                });
                
                try {
                    await onClick();
                } catch (error) {
                    this.toast.show(\`\${L.purchaseError}: \${error.message}\`, 'error');
                } finally {
                    btn.disabled = false;
                    btn.textContent = L.autoBuyButton;
                    Utils.applyStyles(btn, {
                        backgroundColor: "var(--color-primary)",
                        cursor: "pointer"
                    });
                }
            });

            return btn;
        }

        createInfoSpan() {
            const span = document.createElement("span");
            span.textContent = \`\${L.missingPrefix}0\${L.missingUnit}\`;
            Utils.applyStyles(span, CONFIG.STYLES.infoSpan);
            return span;
        }

        async updateInfoSpans(type) {
            const requirements = await MaterialCalculator.calculateRequirements(type);
            const className = type === 'production' ? 'material-info-span' : 'house-material-info-span';
            const spans = document.querySelectorAll(\`.\${className}\`);

            spans.forEach((span, index) => {
                if (requirements[index]) {
                    const needed = requirements[index].supplementNeeded;
                    span.textContent = \`\${L.missingPrefix}\${needed}\${L.missingUnit}\`;
                    span.style.color = needed > 0 ? '#ff6b6b' : 'var(--color-text-dark-mode)';
                }
            });
        }

        async purchaseFlow(type) {
            if (!this.loggerReady) {
                this.toast.show(L.wsNotAvailable, 'error');
                return;
            }

            const requirements = await MaterialCalculator.calculateRequirements(type);
            const needToBuy = requirements.filter(item => item.supplementNeeded > 0 && item.itemId);

            if (needToBuy.length === 0) {
                this.toast.show(L.noMaterialsNeeded, 'info');
                return;
            }

            const itemList = needToBuy.map(item =>
                \`\${item.materialName}: \${item.supplementNeeded}\${L.each}\`
            ).join(', ');

            this.toast.show(\`\${L.startPurchasing} \${needToBuy.length} \${L.materials}: \${itemList}\`, 'info');

            try {
                // ËΩ¨Êç¢‰∏∫ÊâπÈáèË¥≠‰π∞Ê†ºÂºè
                const purchaseItems = needToBuy.map(item => ({
                    itemHrid: item.itemId,
                    quantity: item.supplementNeeded,
                    materialName: item.materialName
                }));

                // ÈÄöËøáPostMessageË∞ÉÁî®ÊâπÈáèË¥≠‰π∞
                const results = await this.postMessageAPI.batchPurchase(purchaseItems, 800);

                // ÊòæÁ§∫Ë¥≠‰π∞ÁªìÊûú
                let successCount = 0;
                let totalCost = 0;

                results.forEach(result => {
                    if (result.success) {
                        successCount++;
                        const cost = result.priceAnalysis?.totalCost || 0;
                        totalCost += cost;

                        this.toast.show(
                            \`\${L.purchased} \${result.item.materialName || result.item.itemHrid} x\${result.item.quantity} (\${cost}\${L.coins})\`,
                            'success'
                        );
                    } else {
                        this.toast.show(
                            \`\${L.purchaseFailed} \${result.item.materialName || result.item.itemHrid}: \${result.error}\`,
                            'error'
                        );
                    }
                });

                // ÊòæÁ§∫ÊÄªÁªì
                if (successCount > 0) {
                    this.toast.show(
                        \`\${L.purchaseComplete} \${L.purchaseSuccess} \${successCount}/\${needToBuy.length} \${L.materials}Ôºå\${L.totalCost} \${totalCost} \${L.coins}\`,
                        'success',
                        5000
                    );

                    // Êõ¥Êñ∞UIÊòæÁ§∫
                    setTimeout(() => this.updateInfoSpans(type), 2000);
                } else {
                    this.toast.show(L.allPurchasesFailed, 'error');
                }

            } catch (error) {
                this.toast.show(\`\${L.purchaseError}: \${error.message}\`, 'error');
            }
        }

        initObserver() {
            if (this.observer) return; // ÈÅøÂÖçÈáçÂ§çÂàùÂßãÂåñ

            this.observer = new MutationObserver(() => {
                this.setupProductionUI();
                this.setupHouseUI();
            });

            this.observer.observe(document.body, { childList: true, subtree: true });

            // ÁõëÂê¨ËæìÂÖ•ÂèòÂåñ
            document.addEventListener('input', (e) => {
                if (e.target.classList.contains('Input_input__2-t98')) {
                    setTimeout(() => this.updateInfoSpans('production'), 100);
                }
            });

            // Á´ãÂç≥ËÆæÁΩÆUI
            this.setupProductionUI();
            this.setupHouseUI();
        }

        setupProductionUI() {
            document.querySelectorAll(CONFIG.SELECTORS.production.container).forEach(panel => {
                if (panel.dataset.buttonInserted) return;

                const requirements = panel.querySelector(CONFIG.SELECTORS.production.requirements);
                if (!requirements) return;

                panel.dataset.buttonInserted = "true";

                // ËÆæÁΩÆÁΩëÊ†ºÂ∏ÉÂ±Ä - ‰øùÊåÅÂéüÊúâËÆæËÆ°
                if (!requirements.dataset.modified) {
                    requirements.dataset.modified = "true";
                    requirements.style.gridTemplateColumns = "auto min-content auto auto";

                    // Ê∑ªÂä†‰ø°ÊÅØÊòæÁ§∫ - ‰øùÊåÅÂéüÊúâ‰ΩçÁΩÆÂíåÊ†∑Âºè
                    requirements.querySelectorAll(CONFIG.SELECTORS.common.itemContainer).forEach(item => {
                        if (item.nextSibling?.classList?.contains('material-info-span')) return;
                        const span = this.createInfoSpan();
                        span.className = 'material-info-span';
                        item.parentNode.insertBefore(span, item.nextSibling);
                    });

                    setTimeout(() => this.updateInfoSpans('production'), 100);
                }

                // Ê∑ªÂä†Ë¥≠‰π∞ÊåâÈíÆ - ‰øùÊåÅÂéüÊúâ‰ΩçÁΩÆ
                const nameDiv = panel.querySelector(CONFIG.SELECTORS.production.nameDiv);
                if (nameDiv && !nameDiv.nextSibling?.textContent?.includes('üõí')) {
                    const btn = this.createButton(() => this.purchaseFlow('production'));
                    btn.style.marginLeft = '10px';
                    nameDiv.parentNode.insertBefore(btn, nameDiv.nextSibling);
                }
            });
        }

        setupHouseUI() {
            document.querySelectorAll(CONFIG.SELECTORS.house.container).forEach(panel => {
                if (panel.dataset.autoBuyButtonInserted) return;

                const requirements = panel.querySelector(CONFIG.SELECTORS.house.requirements);
                if (!requirements) return;

                panel.dataset.autoBuyButtonInserted = "true";

                // ËÆæÁΩÆÁΩëÊ†ºÂ∏ÉÂ±ÄÂíå‰ø°ÊÅØÊòæÁ§∫ - ‰øùÊåÅÂéüÊúâËÆæËÆ°
                if (!requirements.dataset.houseModified) {
                    requirements.dataset.houseModified = "true";
                    requirements.style.gridTemplateColumns = "auto auto auto 120px";

                    requirements.querySelectorAll(CONFIG.SELECTORS.common.itemContainer).forEach(item => {
                        if (item.nextSibling?.classList?.contains('house-material-info-span')) return;
                        const span = this.createInfoSpan();
                        span.className = 'house-material-info-span';
                        item.parentNode.insertBefore(span, item.nextSibling);
                    });

                    setTimeout(() => this.updateInfoSpans('house'), 100);
                }

                // Ê∑ªÂä†Ë¥≠‰π∞ÊåâÈíÆ - ‰øùÊåÅÂéüÊúâ‰ΩçÁΩÆ
                const headerDiv = panel.querySelector(CONFIG.SELECTORS.house.headerDiv);
                if (headerDiv) {
                    const btn = this.createButton(() => this.purchaseFlow('house'));
                    btn.style.marginBottom = '10px';
                    btn.style.display = 'block';
                    btn.style.width = 'fit-content';
                    headerDiv.parentNode.insertBefore(btn, headerDiv);
                }
            });
        }
    }

    // ÂàùÂßãÂåñÂ∫îÁî®
    const app = new UIManager();

    // ÂÆöÊúüÊ∏ÖÁêÜtooltip - ‰øÆÂ§çÁâàÊú¨ÔºåÊõ¥Âä†Ë∞®ÊÖé
    setInterval(() => {
        document.querySelectorAll('.ItemTooltipText_itemTooltipText__zFq3A').forEach(tooltip => {
            // Âè™ÈöêËóèÊ≤°Êúâmouseover‰∫ã‰ª∂ÁöÑtooltip
            if (tooltip.parentElement && !tooltip.parentElement.matches(':hover')) {
                tooltip.parentElement.style.display = 'none';
            }
        });
    }, 5000);

})();
    `;

    // Êú¨Âú∞Ê≥®ÂÖ•ËÑöÊú¨ÁöÑÂáΩÊï∞
    function injectLocalScript() {
        if (scriptInjected) {
            return Promise.resolve();
        }

        return new Promise((resolve, reject) => {
            try {
                // ÂàõÂª∫scriptÂÖÉÁ¥†Âπ∂Áõ¥Êé•ÊèíÂÖ•‰ª£Á†Å
                const script = document.createElement('script');
                script.type = 'text/javascript';
                script.textContent = AUTO_BUY_SCRIPT;

                // Ê∑ªÂä†Âà∞Â§¥ÈÉ®
                (document.head || document.documentElement).appendChild(script);

                scriptInjected = true;
                resolve();
            } catch (error) {
                reject(error);
            }
        });
    }

    // ÂÖ®Â±Ä WebSocket ÂÆû‰æãÂ≠òÂÇ®
    window.wsInstances = [];
    window.currentWS = null;

    // Ê∂àÊÅØÁõëÂê¨Âô®ÂíåÂ§ÑÁêÜÂô®
    window.wsMessageListeners = new Set();
    window.wsRequestHandlers = new Map();

    // Ë¥≠‰π∞Áõ∏ÂÖ≥ÁöÑÊ∂àÊÅØÈòüÂàó
    window.wsPurchaseQueue = [];
    window.wsMarketDataCache = new Map();

    // PostMessage ÈÄö‰ø°Â§ÑÁêÜÂô®
    function setupPostMessageAPI() {
        window.addEventListener('message', async (event) => {
            // Âè™Â§ÑÁêÜÊù•Ëá™ÂêåÊ∫êÁöÑÊ∂àÊÅØ
            if (event.origin !== window.location.origin) return;

            const message = event.data;
            if (!message || message.type !== 'ws_request') return;

            try {
                let result;
                switch (message.action) {
                    case 'check_api':
                        result = { available: true, ws_ready: !!window.currentWS };
                        break;

                    case 'get_market_data':
                        result = await handleGetMarketData(message.data);
                        break;

                    case 'smart_purchase':
                        result = await handleSmartPurchase(message.data);
                        break;

                    case 'batch_purchase':
                        result = await handleBatchPurchase(message.data);
                        break;

                    default:
                        throw new Error(`Êú™Áü•ÁöÑÊìç‰Ωú: ${message.action}`);
                }

                // ÂèëÈÄÅÊàêÂäüÂìçÂ∫î
                window.postMessage({
                    type: 'ws_response',
                    action: message.action,
                    success: true,
                    data: result,
                    requestId: message.requestId
                }, window.location.origin);

            } catch (error) {
                // ÂèëÈÄÅÈîôËØØÂìçÂ∫î
                window.postMessage({
                    type: 'ws_response',
                    action: message.action,
                    success: false,
                    error: error.message,
                    requestId: message.requestId
                }, window.location.origin);
            }
        });
    }

    // Â§ÑÁêÜËé∑ÂèñÂ∏ÇÂú∫Êï∞ÊçÆËØ∑Ê±Ç
    async function handleGetMarketData({ itemHrid, useCache = true }) {
        const fullItemHrid = itemHrid.startsWith('/items/') ? itemHrid : `/items/${itemHrid}`;

        // Ê£ÄÊü•ÁºìÂ≠ò
        if (useCache && window.wsMarketDataCache.has(fullItemHrid)) {
            const cached = window.wsMarketDataCache.get(fullItemHrid);
            if (Date.now() - cached.timestamp < 60000) { // 1ÂàÜÈíüÁºìÂ≠ò
                return cached.data;
            }
        }

        const requestData = {
            type: "get_market_item_order_books",
            getMarketItemOrderBooksData: {
                itemHrid: fullItemHrid
            }
        };

        return new Promise((resolve, reject) => {
            if (!window.currentWS || window.currentWS.readyState !== WebSocket.OPEN) {
                reject(new Error('WebSocketËøûÊé•‰∏çÂèØÁî®'));
                return;
            }

            const timeout = setTimeout(() => {
                reject(new Error('Ëé∑ÂèñÂ∏ÇÂú∫Êï∞ÊçÆË∂ÖÊó∂'));
            }, 8000);

            const responseHandler = (responseData) => {
                if (responseData.type === 'market_item_order_books_updated' &&
                    responseData.marketItemOrderBooks?.itemHrid === fullItemHrid) {
                    clearTimeout(timeout);
                    cleanup();
                    resolve(responseData.marketItemOrderBooks);
                }
            };

            const cleanup = () => {
                if (window.wsRequestHandlers.has('market_item_order_books_updated')) {
                    const handlers = window.wsRequestHandlers.get('market_item_order_books_updated');
                    handlers.delete(responseHandler);
                    if (handlers.size === 0) {
                        window.wsRequestHandlers.delete('market_item_order_books_updated');
                    }
                }
            };

            // Ê≥®ÂÜåÂìçÂ∫îÂ§ÑÁêÜÂô®
            if (!window.wsRequestHandlers.has('market_item_order_books_updated')) {
                window.wsRequestHandlers.set('market_item_order_books_updated', new Set());
            }
            window.wsRequestHandlers.get('market_item_order_books_updated').add(responseHandler);

            // ÂèëÈÄÅËØ∑Ê±Ç
            window.currentWS.send(JSON.stringify(requestData));
        });
    }

    // Â§ÑÁêÜÊô∫ËÉΩË¥≠‰π∞ËØ∑Ê±Ç
    async function handleSmartPurchase({ itemHrid, quantity }) {
        // Ëé∑ÂèñÂ∏ÇÂú∫Êï∞ÊçÆ
        const marketData = await handleGetMarketData({ itemHrid });

        // ÂàÜÊûê‰ª∑Ê†º
        const priceAnalysis = analyzeMarketPrice(marketData, quantity);

        // ÊâßË°åË¥≠‰π∞
        const result = await executePurchase(itemHrid, quantity, priceAnalysis.maxPrice);

        return {
            success: true,
            result: result,
            priceAnalysis: priceAnalysis
        };
    }

    // Â§ÑÁêÜÊâπÈáèË¥≠‰π∞ËØ∑Ê±Ç
    async function handleBatchPurchase({ items, delayBetween = 800 }) {
        const results = [];

        for (let i = 0; i < items.length; i++) {
            const item = items[i];

            try {
                const result = await handleSmartPurchase({
                    itemHrid: item.itemHrid,
                    quantity: item.quantity
                });
                results.push({ item, ...result });

                // Âª∂ËøüÈÅøÂÖçËøá‰∫éÈ¢ëÁπÅÁöÑËØ∑Ê±Ç
                if (i < items.length - 1 && delayBetween > 0) {
                    await new Promise(resolve => setTimeout(resolve, delayBetween));
                }
            } catch (error) {
                results.push({
                    item,
                    success: false,
                    error: error.message
                });
            }
        }

        return results;
    }

    // ÊâßË°åË¥≠‰π∞Êìç‰Ωú
    async function executePurchase(itemHrid, quantity, price, enhancementLevel = 0) {
        const fullItemHrid = itemHrid.startsWith('/items/') ? itemHrid : `/items/${itemHrid}`;

        const requestData = {
            type: "post_market_order",
            postMarketOrderData: {
                isSell: false,
                itemHrid: fullItemHrid,
                enhancementLevel: enhancementLevel,
                quantity: quantity,
                price: price,
                isInstantOrder: true
            }
        };

        return new Promise((resolve, reject) => {
            if (!window.currentWS || window.currentWS.readyState !== WebSocket.OPEN) {
                reject(new Error('WebSocketËøûÊé•‰∏çÂèØÁî®'));
                return;
            }

            const timeout = setTimeout(() => {
                reject(new Error('Ë¥≠‰π∞Ë∂ÖÊó∂'));
            }, 15000);

            window.currentWS.send(JSON.stringify(requestData));

            // Á≠âÂæÖË¥≠‰π∞ÂÆåÊàêÊàñÈîôËØØ
            const checkResult = () => {
                const recent = window.wsPurchaseQueue.filter(item =>
                    Date.now() - item.timestamp < 15000
                );

                const completed = recent.find(item => item.type === 'purchase_completed');
                const error = recent.find(item => item.type === 'error');

                if (completed) {
                    clearTimeout(timeout);
                    resolve(completed.data);
                    return;
                }

                if (error) {
                    clearTimeout(timeout);
                    reject(new Error(error.data.message || 'Ë¥≠‰π∞Â§±Ë¥•'));
                    return;
                }

                setTimeout(checkResult, 200);
            };

            checkResult();
        });
    }

    // ÂàÜÊûêÂ∏ÇÂú∫‰ª∑Ê†º
    function analyzeMarketPrice(marketData, neededQuantity) {
        if (!marketData.orderBooks || !marketData.orderBooks[0] || !marketData.orderBooks[0].asks) {
            throw new Error('Êó†ÊïàÁöÑÂ∏ÇÂú∫Êï∞ÊçÆÁªìÊûÑ');
        }

        const asks = marketData.orderBooks[0].asks;
        if (asks.length === 0) {
            throw new Error('Ê≤°ÊúâÂèØÁî®ÁöÑÂçñÂçï');
        }

        let cumulativeQuantity = 0;
        let targetPrice = 0;
        let totalCost = 0;
        let priceBreakdown = [];

        for (const ask of asks) {
            const availableFromThisOrder = Math.min(ask.quantity, neededQuantity - cumulativeQuantity);

            cumulativeQuantity += availableFromThisOrder;
            targetPrice = ask.price; // ÊúÄÈ´ò‰ª∑Ê†º
            totalCost += availableFromThisOrder * ask.price;

            priceBreakdown.push({
                price: ask.price,
                quantity: availableFromThisOrder,
                cost: availableFromThisOrder * ask.price
            });

            if (cumulativeQuantity >= neededQuantity) {
                break;
            }
        }

        if (cumulativeQuantity < neededQuantity) {
            throw new Error(`Â∏ÇÂú∫Â∫ìÂ≠ò‰∏çË∂≥„ÄÇÂèØÁî®: ${cumulativeQuantity}, ÈúÄË¶Å: ${neededQuantity}`);
        }

        return {
            maxPrice: targetPrice,
            averagePrice: Math.ceil(totalCost / neededQuantity),
            totalCost: totalCost,
            availableQuantity: cumulativeQuantity,
            priceBreakdown: priceBreakdown
        };
    }

    // Ê∂àÊÅØÂàÜÂèëÂô®
    function dispatchMessage(data, direction) {
        // ÈÄöÁü•ÊâÄÊúâÁõëÂê¨Âô®
        window.wsMessageListeners.forEach(listener => {
            try {
                listener(data, direction);
            } catch (e) {
                // ÈùôÈªòÈîôËØØ
            }
        });

        // Â§ÑÁêÜÁâπÂÆöÁöÑËØ∑Ê±ÇÂìçÂ∫î
        if (data.type && window.wsRequestHandlers.has(data.type)) {
            const handlers = window.wsRequestHandlers.get(data.type);
            handlers.forEach(handler => {
                try {
                    handler(data);
                } catch (e) {
                    // ÈùôÈªòÈîôËØØ
                }
            });
        }

        // ÁºìÂ≠òÂ∏ÇÂú∫Êï∞ÊçÆ
        if (data.type === 'market_item_order_books_updated') {
            const itemHrid = data.marketItemOrderBooks?.itemHrid;
            if (itemHrid) {
                window.wsMarketDataCache.set(itemHrid, {
                    data: data.marketItemOrderBooks,
                    timestamp: Date.now()
                });
                // Ê∏ÖÁêÜËøáÊúüÁºìÂ≠ò (5ÂàÜÈíü)
                setTimeout(() => {
                    if (window.wsMarketDataCache.has(itemHrid)) {
                        const cached = window.wsMarketDataCache.get(itemHrid);
                        if (Date.now() - cached.timestamp > 300000) {
                            window.wsMarketDataCache.delete(itemHrid);
                        }
                    }
                }, 300000);
            }
        }

        // Â§ÑÁêÜË¥≠‰π∞ÂÆåÊàêÊ∂àÊÅØ
        if (data.type === 'info' && data.message === 'infoNotification.buyOrderCompleted') {
            window.wsPurchaseQueue.push({
                type: 'purchase_completed',
                data: data,
                timestamp: Date.now()
            });
        }

        // Â§ÑÁêÜÈîôËØØÊ∂àÊÅØ
        if (data.type === 'error') {
            window.wsPurchaseQueue.push({
                type: 'error',
                data: data,
                timestamp: Date.now()
            });
        }
    }

    const OriginalWebSocket = window.WebSocket;
    window.WebSocket = new Proxy(OriginalWebSocket, {
        construct(target, args) {
            const ws = new target(...args);
            const url = args[0];

            // ‰øùÂ≠òÂà∞ÂÖ®Â±ÄÂèòÈáè
            window.wsInstances.push(ws);
            window.currentWS = ws; // ÊúÄÊñ∞ÁöÑËøûÊé•

            // Êã¶Êà™ .send()
            const originalSend = ws.send;
            ws.send = function (data) {
                try {
                    const parsed = JSON.parse(data);
                    // ÂàÜÂèëÊ∂àÊÅØ
                    dispatchMessage(parsed, 'send');
                } catch (e) {
                    // ÈùôÈªòÂ§ÑÁêÜÈùûJSONÊï∞ÊçÆ
                }
                return originalSend.call(this, data);
            };

            // Êã¶Êà™ .onmessage
            ws.addEventListener("message", function (event) {
                try {
                    const parsed = JSON.parse(event.data);
                    // ÂàÜÂèëÊ∂àÊÅØ
                    dispatchMessage(parsed, 'receive');
                } catch (e) {
                    // ÈùôÈªòÂ§ÑÁêÜÈùûJSONÊï∞ÊçÆ
                }
            });

            ws.addEventListener("open", function () {
                // Âú®Á¨¨‰∏Ä‰∏™WebSocketËøûÊé•Âª∫Á´ãÂêéÊ≥®ÂÖ•Êú¨Âú∞ËÑöÊú¨
                if (window.wsInstances.length === 1 && !scriptInjected) {
                    // Âª∂Ëøü‰∏ÄÂ∞èÊÆµÊó∂Èó¥Á°Æ‰øùWebSocketÂÆåÂÖ®Â∞±Áª™
                    setTimeout(async () => {
                        try {
                            await injectLocalScript();
                            console.info('%c[MWI-AutoBuyer] ÁïåÈù¢Ê≥®ÂÖ•ÊàêÂäü', 'color: #4CAF50; font-weight: bold;');
                        } catch (error) {
                            console.error('%c[MWI-AutoBuyer] ÁïåÈù¢Ê≥®ÂÖ•Â§±Ë¥•:', 'color: #F44336; font-weight: bold;', error);
                        }
                    }, 1000);
                }

                // ÈÄöÁü•ÂÖ∂‰ªñËÑöÊú¨WebSocketÂ∑≤Â∞±Áª™
                window.postMessage({
                    type: 'ws_ready',
                    detail: { ws, url }
                }, window.location.origin);
            });

            ws.addEventListener("close", function (e) {
                // ‰ªéÊï∞ÁªÑ‰∏≠ÁßªÈô§ÂÖ≥Èó≠ÁöÑËøûÊé•
                const index = window.wsInstances.indexOf(ws);
                if (index > -1) {
                    window.wsInstances.splice(index, 1);
                }
                if (window.currentWS === ws) {
                    window.currentWS = window.wsInstances[window.wsInstances.length - 1] || null;
                }
            });

            ws.addEventListener("error", function (e) {
                // ÈùôÈªòÂ§ÑÁêÜÈîôËØØ
            });

            return ws;
        }
    });

    // Ê∏ÖÁêÜÁºìÂ≠ò
    window.clearWSCache = function() {
        window.wsMarketDataCache.clear();
        window.wsPurchaseQueue.length = 0;
        return true;
    };

    // ÂàùÂßãÂåñPostMessage API
    setupPostMessageAPI();

})();